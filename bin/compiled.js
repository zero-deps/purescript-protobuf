// Generated by purs bundle 0.13.8
var PS = {};
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];                    
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };
  exports["Apply"] = Apply;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function(exports) {
  "use strict";

  exports.snoc = function (l) {
    return function (e) {
      var l1 = l.slice();
      l1.push(e);
      return l1;
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  exports["snoc"] = $foreign.snoc;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Bifunctor"] = $PS["Data.Bifunctor"] || {};
  var exports = $PS["Data.Bifunctor"];
  var Control_Category = $PS["Control.Category"];                
  var Bifunctor = function (bimap) {
      this.bimap = bimap;
  };
  var bimap = function (dict) {
      return dict.bimap;
  };
  var lmap = function (dictBifunctor) {
      return function (f) {
          return bimap(dictBifunctor)(f)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  exports["Bifunctor"] = Bifunctor;
  exports["lmap"] = lmap;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];               
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  exports["Functor"] = Functor;
  exports["map"] = map;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Functor = $PS["Data.Functor"];          
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  var functorEither = new Data_Functor.Functor(function (f) {
      return function (m) {
          if (m instanceof Left) {
              return new Left(m.value0);
          };
          if (m instanceof Right) {
              return new Right(f(m.value0));
          };
          throw new Error("Failed pattern match at Data.Either (line 38, column 1 - line 38, column 52): " + [ m.constructor.name ]);
      };
  });
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either (line 238, column 1 - line 238, column 64): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return new Left(v(v2.value0));
              };
              if (v2 instanceof Right) {
                  return new Right(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Either (line 46, column 1 - line 48, column 36): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var applyEither = new Control_Apply.Apply(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return new Left(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map(functorEither)(v.value0)(v1);
          };
          throw new Error("Failed pattern match at Data.Either (line 82, column 1 - line 84, column 30): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindEither = new Control_Bind.Bind(function () {
      return applyEither;
  }, either(function (e) {
      return function (v) {
          return new Left(e);
      };
  })(function (a) {
      return function (f) {
          return f(a);
      };
  }));
  var applicativeEither = new Control_Applicative.Applicative(function () {
      return applyEither;
  }, Right.create);
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["bifunctorEither"] = bifunctorEither;
  exports["applicativeEither"] = applicativeEither;
  exports["bindEither"] = bindEither;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function(exports) {
  "use strict"

  exports.joinFloat64 = bitsLow => bitsHigh => {
    var TWO_TO_32 = 4294967296
    var TWO_TO_52 = 4503599627370496
    var sign = ((bitsHigh >> 31) * 2 + 1)
    var exp = (bitsHigh >>> 20) & 0x7FF
    var mant = TWO_TO_32 * (bitsHigh & 0xFFFFF) + bitsLow

    if (exp == 0x7FF) {
      if (mant) {
        return NaN
      } else {
        return sign * Infinity
      }
    }

    if (exp == 0) {
      // Denormal.
      return sign * Math.pow(2, -1074) * mant
    } else {
      return sign * Math.pow(2, exp - 1075) *
              (mant + TWO_TO_52)
    }
  }

  const joinUint64 = (bitsLow, bitsHigh) => {
    var TWO_TO_32 = 4294967296
    return bitsHigh * TWO_TO_32 + (bitsLow >>> 0);
  }

  exports.joinInt64 = bitsLow => bitsHigh => {
    // If the high bit is set, do a manual two's complement conversion.
    var sign = (bitsHigh & 0x80000000)
    if (sign) {
      bitsLow = (~bitsLow + 1) >>> 0
      bitsHigh = ~bitsHigh >>> 0
      if (bitsLow == 0) {
        bitsHigh = (bitsHigh + 1) >>> 0
      }
    }

    var result = joinUint64(bitsLow, bitsHigh)
    return sign ? -result : result
  }

  exports.joinBigInt = bitsLow => bitsHigh => {
    // If the high bit is set, do a manual two's complement conversion.
    var sign = (bitsHigh & 0x80000000)
    if (sign) {
      bitsLow = (~bitsLow + 1) >>> 0
      bitsHigh = ~bitsHigh >>> 0
      if (bitsLow == 0) {
        bitsHigh = (bitsHigh + 1) >>> 0
      }
    }
    var TWO_TO_32 = 4294967296n
    var result = BigInt(bitsHigh) * TWO_TO_32 + BigInt((bitsLow >>> 0))
    return sign ? -result : result
  }

  exports.readSplitVarint64 = bytes => pos => success => failure => {
    var temp = 128
    var lowBits = 0
    var highBits = 0

    // Read the first four bytes of the varint, stopping at the terminator if we
    // see it.
    for (var i = 0; i < 4 && temp >= 128; i++) {
      temp = bytes[pos++];
      lowBits |= (temp & 0x7F) << (i * 7);
    }

    if (temp >= 128) {
      // Read the fifth byte, which straddles the low and high dwords.
      temp = bytes[pos++];
      lowBits |= (temp & 0x7F) << 28;
      highBits |= (temp & 0x7F) >> 4;
    }

    if (temp >= 128) {
      // Read the sixth through tenth byte.
      for (var i = 0; i < 5 && temp >= 128; i++) {
        temp = bytes[pos++];
        highBits |= (temp & 0x7F) << (i * 7 + 3);
      }
    }

    if (temp < 128) {
      return success({ pos: pos, val: { low: lowBits >>> 0, high: highBits >>> 0 }})
    } else {
      return failure('Failed to read varint, encoding is invalid.')
    }
  }
})(PS["Proto.Decode"] = PS["Proto.Decode"] || {});
(function(exports) {
  "use strict"

  exports.length = xs => xs.length

  exports.indexUnsafe = xs => i => xs[i]

  exports.slice = xs => start => end => xs.slice(start, end)

  exports.fromArray = xs => new Uint8Array(xs)

  exports.concatAll = xs => {
    const zs = new Uint8Array(xs.reduce((acc, x) => acc + x.length, 0))
    xs.reduce((acc, x) => {
      zs.set(x, acc)
      return acc + x.length
    }, 0)
    return zs
  }
})(PS["Proto.Uint8Array"] = PS["Proto.Uint8Array"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Proto.Uint8Array"] = $PS["Proto.Uint8Array"] || {};
  var exports = $PS["Proto.Uint8Array"];
  var $foreign = $PS["Proto.Uint8Array"];
  var Data_Either = $PS["Data.Either"];   
  var index = function (xs) {
      return function (pos) {
          var len = $foreign.length(xs);
          var $0 = 0 <= pos && pos < len;
          if ($0) {
              return new Data_Either.Right($foreign.indexUnsafe(xs)(pos));
          };
          return new Data_Either.Left({
              pos: pos,
              len: len
          });
      };
  };
  exports["index"] = index;
  exports["length"] = $foreign.length;
  exports["slice"] = $foreign.slice;
  exports["concatAll"] = $foreign.concatAll;
  exports["fromArray"] = $foreign.fromArray;
})(PS);
(function(exports) {
  "use strict"

  exports.numOfBytes = function(string) {
    var len = 0,
        c = 0
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i)
      if (c < 128)
        len += 1
      else if (c < 2048)
        len += 2
      else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
        ++i
        len += 4
      } else
        len += 3
    }
    return len
  }

  exports.toString = function(buffer) {
    var start = 0
    var end = buffer.length
    var len = end - start
    if (len < 1)
      return ""
    var parts = null,
      chunk = [],
      i = 0, // char offset
      t     // temporary
    while (start < end) {
      t = buffer[start++]
      if (t < 128)
        chunk[i++] = t
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000
        chunk[i++] = 0xD800 + (t >> 10)
        chunk[i++] = 0xDC00 + (t & 1023)
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk))
        i = 0
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))
      return parts.join("")
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i))
  }

  exports.toUint8Array = function(string) {
    return function(len) {
      var buffer = new Uint8Array(len)
      var offset = 0
      var c1, // character 1
          c2 // character 2
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i)
        if (c1 < 128) {
          buffer[offset++] = c1
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6       | 192
          buffer[offset++] = c1       & 63 | 128
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
          c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)
          ++i
          buffer[offset++] = c1 >> 18      | 240
          buffer[offset++] = c1 >> 12 & 63 | 128
          buffer[offset++] = c1 >> 6  & 63 | 128
          buffer[offset++] = c1       & 63 | 128
        } else {
          buffer[offset++] = c1 >> 12      | 224
          buffer[offset++] = c1 >> 6  & 63 | 128
          buffer[offset++] = c1       & 63 | 128
        }
      }
      return buffer
    }
  }
})(PS["Proto.Utf8"] = PS["Proto.Utf8"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Proto.Utf8"] = $PS["Proto.Utf8"] || {};
  var exports = $PS["Proto.Utf8"];
  var $foreign = $PS["Proto.Utf8"];
  exports["numOfBytes"] = $foreign.numOfBytes;
  exports["toString"] = $foreign.toString;
  exports["toUint8Array"] = $foreign.toUint8Array;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Proto.Decode"] = $PS["Proto.Decode"] || {};
  var exports = $PS["Proto.Decode"];
  var $foreign = $PS["Proto.Decode"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Show = $PS["Data.Show"];
  var Data_Unit = $PS["Data.Unit"];
  var Proto_Uint8Array = $PS["Proto.Uint8Array"];
  var Proto_Utf8 = $PS["Proto.Utf8"];                
  var OutOfBound = (function () {
      function OutOfBound(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      OutOfBound.create = function (value0) {
          return function (value1) {
              return new OutOfBound(value0, value1);
          };
      };
      return OutOfBound;
  })();
  var BadWireType = (function () {
      function BadWireType(value0) {
          this.value0 = value0;
      };
      BadWireType.create = function (value0) {
          return new BadWireType(value0);
      };
      return BadWireType;
  })();
  var BadType = (function () {
      function BadType(value0) {
          this.value0 = value0;
      };
      BadType.create = function (value0) {
          return new BadType(value0);
      };
      return BadType;
  })();
  var UnexpectedCase = (function () {
      function UnexpectedCase(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      UnexpectedCase.create = function (value0) {
          return function (value1) {
              return new UnexpectedCase(value0, value1);
          };
      };
      return UnexpectedCase;
  })();
  var MissingFields = (function () {
      function MissingFields(value0) {
          this.value0 = value0;
      };
      MissingFields.create = function (value0) {
          return new MissingFields(value0);
      };
      return MissingFields;
  })();
  var IntTooLong = (function () {
      function IntTooLong() {

      };
      IntTooLong.value = new IntTooLong();
      return IntTooLong;
  })();
  var ErrMsg = (function () {
      function ErrMsg(value0) {
          this.value0 = value0;
      };
      ErrMsg.create = function (value0) {
          return new ErrMsg(value0);
      };
      return ErrMsg;
  })();
  var skip = function (n) {
      return function (xs) {
          return function (pos0) {
              var len = Proto_Uint8Array.length(xs);
              var $14 = (pos0 + n | 0) > len;
              if ($14) {
                  return new Data_Either.Left(new OutOfBound(pos0 + n | 0, len));
              };
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: pos0 + n | 0,
                  val: Data_Unit.unit
              });
          };
      };
  };
  var signedVarint64 = function (xs) {
      return function (pos) {
          return Control_Bind.bind(Data_Either.bindEither)($foreign.readSplitVarint64(xs)(pos)(function (x) {
              return new Data_Either.Right(x);
          })(function (x) {
              return Data_Either.Left.create(new ErrMsg(x));
          }))(function (v) {
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: v.pos,
                  val: $foreign.joinInt64(v.val.low)(v.val.high)
              });
          });
      };
  };
  var showError = new Data_Show.Show(function (v) {
      if (v instanceof OutOfBound) {
          return "index=" + (Data_Show.show(Data_Show.showInt)(v.value0) + (" out of bound=" + Data_Show.show(Data_Show.showInt)(v.value1)));
      };
      if (v instanceof BadWireType) {
          return "bad wire type=" + Data_Show.show(Data_Show.showInt)(v.value0);
      };
      if (v instanceof BadType) {
          return "bad type=" + Data_Show.show(Data_Show.showInt)(v.value0);
      };
      if (v instanceof UnexpectedCase) {
          return "unexpected case val=" + (Data_Show.show(Data_Show.showInt)(v.value0) + (" pos=" + Data_Show.show(Data_Show.showInt)(v.value1)));
      };
      if (v instanceof MissingFields) {
          return "missing fields in=" + v.value0;
      };
      if (v instanceof IntTooLong) {
          return "varint32 too long";
      };
      if (v instanceof ErrMsg) {
          return v.value0;
      };
      throw new Error("Failed pattern match at Proto.Decode (line 47, column 1 - line 54, column 22): " + [ v.constructor.name ]);
  });
  var index = function (xs) {
      return function (pos) {
          return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (x) {
              return new OutOfBound(x.pos, x.len);
          })(Proto_Uint8Array.index(xs)(pos));
      };
  };
  var skip$prime = function ($copy_xs) {
      return function ($copy_pos) {
          var $tco_var_xs = $copy_xs;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(xs, pos) {
              var v = index(xs)(pos);
              if (v instanceof Data_Either.Left) {
                  $tco_done = true;
                  return new Data_Either.Left(v.value0);
              };
              if (v instanceof Data_Either.Right && (v.value0 & 128) === 0) {
                  $tco_done = true;
                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                      pos: pos + 1 | 0,
                      val: Data_Unit.unit
                  });
              };
              if (v instanceof Data_Either.Right) {
                  $tco_var_xs = xs;
                  $copy_pos = pos + 1 | 0;
                  return;
              };
              throw new Error("Failed pattern match at Proto.Decode (line 164, column 3 - line 167, column 32): " + [ v.constructor.name ]);
          };
          while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_xs, $copy_pos);
          };
          return $tco_result;
      };
  };
  var unsignedVarint32 = function (xs) {
      return function (pos) {
          return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos))(function (x) {
              var val = x & 127;
              var $33 = x < 128;
              if ($33) {
                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                      pos: pos + 1 | 0,
                      val: val
                  });
              };
              return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 1 | 0))(function (x1) {
                  var val1 = val | (x1 & 127) << 7;
                  var $34 = x1 < 128;
                  if ($34) {
                      return Control_Applicative.pure(Data_Either.applicativeEither)({
                          pos: pos + 2 | 0,
                          val: val1
                      });
                  };
                  return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 2 | 0))(function (x2) {
                      var val2 = val1 | (x2 & 127) << 14;
                      var $35 = x2 < 128;
                      if ($35) {
                          return Control_Applicative.pure(Data_Either.applicativeEither)({
                              pos: pos + 3 | 0,
                              val: val2
                          });
                      };
                      return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 3 | 0))(function (x3) {
                          var val3 = val2 | (x3 & 127) << 21;
                          var $36 = x3 < 128;
                          if ($36) {
                              return Control_Applicative.pure(Data_Either.applicativeEither)({
                                  pos: pos + 4 | 0,
                                  val: val3
                              });
                          };
                          return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 4 | 0))(function (x4) {
                              var val4 = val3 | (x4 & 15) << 28;
                              var $37 = x4 < 128;
                              if ($37) {
                                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                                      pos: pos + 5 | 0,
                                      val: val4 >>> 0
                                  });
                              };
                              return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 5 | 0))(function (x5) {
                                  var $38 = x5 < 128;
                                  if ($38) {
                                      return Control_Applicative.pure(Data_Either.applicativeEither)({
                                          pos: pos + 6 | 0,
                                          val: val4
                                      });
                                  };
                                  return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 6 | 0))(function (x6) {
                                      var $39 = x6 < 128;
                                      if ($39) {
                                          return Control_Applicative.pure(Data_Either.applicativeEither)({
                                              pos: pos + 7 | 0,
                                              val: val4
                                          });
                                      };
                                      return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 7 | 0))(function (x7) {
                                          var $40 = x7 < 128;
                                          if ($40) {
                                              return Control_Applicative.pure(Data_Either.applicativeEither)({
                                                  pos: pos + 8 | 0,
                                                  val: val4
                                              });
                                          };
                                          return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 8 | 0))(function (x8) {
                                              var $41 = x8 < 128;
                                              if ($41) {
                                                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                                                      pos: pos + 9 | 0,
                                                      val: val4
                                                  });
                                              };
                                              return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos + 9 | 0))(function (x9) {
                                                  var $42 = x9 < 128;
                                                  if ($42) {
                                                      return Control_Applicative.pure(Data_Either.applicativeEither)({
                                                          pos: pos + 10 | 0,
                                                          val: val4
                                                      });
                                                  };
                                                  return Data_Either.Left.create(IntTooLong.value);
                                              });
                                          });
                                      });
                                  });
                              });
                          });
                      });
                  });
              });
          });
      };
  };
  var signedVarint32 = unsignedVarint32;
  var skipType = function (v) {
      return function (v1) {
          return function (v2) {
              var xs = v;
              if (v2 === 0) {
                  return skip$prime(xs)(v1);
              };
              var xs = v;
              if (v2 === 1) {
                  return skip(8)(xs)(v1);
              };
              var xs = v;
              if (v2 === 2) {
                  return Control_Bind.bind(Data_Either.bindEither)(unsignedVarint32(xs)(v1))(function (v3) {
                      return skip(v3.val)(xs)(v3.pos);
                  });
              };
              if (v2 === 3) {
                  var loop = function (xs) {
                      return function (pos) {
                          return Control_Bind.bind(Data_Either.bindEither)(unsignedVarint32(xs)(pos))(function (v3) {
                              var wireType = v3.val & 7;
                              var $50 = wireType !== 4;
                              if ($50) {
                                  return Control_Bind.bind(Data_Either.bindEither)(skipType(xs)(v3.pos)(wireType))(function (v4) {
                                      return loop(xs)(v4.pos);
                                  });
                              };
                              return Control_Applicative.pure(Data_Either.applicativeEither)({
                                  pos: v3.pos,
                                  val: Data_Unit.unit
                              });
                          });
                      };
                  };
                  return loop(v)(v1);
              };
              if (v2 === 5) {
                  return skip(4)(v)(v1);
              };
              return Data_Either.Left.create(new BadWireType(v2));
          };
      };
  };
  var $$double = function (xs) {
      return function (pos) {
          var fixedUint32 = function (pos1) {
              return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos1 + 0 | 0))(function (a) {
                  return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos1 + 1 | 0))(function (b) {
                      return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos1 + 2 | 0))(function (c) {
                          return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos1 + 3 | 0))(function (d) {
                              return Control_Applicative.pure(Data_Either.applicativeEither)({
                                  pos: pos1 + 4 | 0,
                                  val: (a << 0 | b << 8 | c << 16 | d << 24) >>> 0
                              });
                          });
                      });
                  });
              });
          };
          return Control_Bind.bind(Data_Either.bindEither)(fixedUint32(pos))(function (v) {
              return Control_Bind.bind(Data_Either.bindEither)(fixedUint32(v.pos))(function (v1) {
                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                      pos: v1.pos,
                      val: $foreign.joinFloat64(v.val)(v1.val)
                  });
              });
          });
      };
  };
  var bytes = function (xs) {
      return function (pos0) {
          return Control_Bind.bind(Data_Either.bindEither)(unsignedVarint32(xs)(pos0))(function (v) {
              var end = v.pos + v.val | 0;
              var len = Proto_Uint8Array.length(xs);
              var $62 = end > len;
              if ($62) {
                  return new Data_Either.Left(new OutOfBound(end, len));
              };
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: v.pos + v.val | 0,
                  val: Proto_Uint8Array.slice(xs)(v.pos)(end)
              });
          });
      };
  };
  var string = function (xs) {
      return function (pos0) {
          return Control_Bind.bind(Data_Either.bindEither)(bytes(xs)(pos0))(function (v) {
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: v.pos,
                  val: Proto_Utf8.toString(v.val)
              });
          });
      };
  };
  var $$boolean = function (xs) {
      return function (pos) {
          return Control_Bind.bind(Data_Either.bindEither)(index(xs)(pos))(function (x) {
              var $68 = x === 0;
              if ($68) {
                  return Control_Applicative.pure(Data_Either.applicativeEither)({
                      pos: pos + 1 | 0,
                      val: false
                  });
              };
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: pos + 1 | 0,
                  val: true
              });
          });
      };
  };
  var bigInt = function (xs) {
      return function (pos) {
          return Control_Bind.bind(Data_Either.bindEither)($foreign.readSplitVarint64(xs)(pos)(function (x) {
              return new Data_Either.Right(x);
          })(function (x) {
              return Data_Either.Left.create(new ErrMsg(x));
          }))(function (v) {
              return Control_Applicative.pure(Data_Either.applicativeEither)({
                  pos: v.pos,
                  val: $foreign.joinBigInt(v.val.low)(v.val.high)
              });
          });
      };
  };
  exports["OutOfBound"] = OutOfBound;
  exports["BadWireType"] = BadWireType;
  exports["BadType"] = BadType;
  exports["UnexpectedCase"] = UnexpectedCase;
  exports["MissingFields"] = MissingFields;
  exports["IntTooLong"] = IntTooLong;
  exports["ErrMsg"] = ErrMsg;
  exports["index"] = index;
  exports["signedVarint32"] = signedVarint32;
  exports["unsignedVarint32"] = unsignedVarint32;
  exports["signedVarint64"] = signedVarint64;
  exports["bigInt"] = bigInt;
  exports["boolean"] = $$boolean;
  exports["double"] = $$double;
  exports["bytes"] = bytes;
  exports["string"] = string;
  exports["skip'"] = skip$prime;
  exports["skip"] = skip;
  exports["skipType"] = skipType;
  exports["showError"] = showError;
  exports["joinFloat64"] = $foreign.joinFloat64;
  exports["joinInt64"] = $foreign.joinInt64;
  exports["joinBigInt"] = $foreign.joinBigInt;
  exports["readSplitVarint64"] = $foreign.readSplitVarint64;
})(PS);
(function(exports) {
  "use strict"

  exports.splitFloat64 = value => {
    var FLOAT64_MAX = 1.7976931348623157e+308
    var FLOAT64_MIN = 2.2250738585072014e-308
    var TWO_TO_20 = 1048576
    var TWO_TO_32 = 4294967296
    var TWO_TO_52 = 4503599627370496
    var sign = (value < 0) ? 1 : 0
    value = sign ? -value : value

    // Handle zeros.
    if (value === 0) {
      if ((1 / value) > 0) {
        // Positive zero.
        return { low: 0x00000000, high: 0x00000000 }
      } else {
        // Negative zero.
        return { low: 0x00000000, high: 0x80000000 }
      }
    }

    // Handle nans.
    if (isNaN(value)) {
      return { low: 0xFFFFFFFF, high: 0x7FFFFFFF }
    }

    // Handle infinities.
    if (value > FLOAT64_MAX) {
      return { low: 0, high: ((sign << 31) | (0x7FF00000)) >>> 0 }
    }

    // Handle denormals.
    if (value < FLOAT64_MIN) {
      // Number is a denormal.
      var mant = value / Math.pow(2, -1074)
      var mantHigh = (mant / TWO_TO_32)
      return { low: (mant >>> 0), high: ((sign << 31) | mantHigh) >>> 0 }
    }

    var exp = Math.floor(Math.log(value) / Math.LN2)
    if (exp == 1024) exp = 1023
    var mant = value * Math.pow(2, -exp)

    var mantHigh = (mant * TWO_TO_20) & 0xFFFFF
    var mantLow = (mant * TWO_TO_52) >>> 0

    return { low: mantLow, high: ((sign << 31) | ((exp + 1023) << 20) | mantHigh) >>> 0 }
  }

  exports.writeSplitVarint64 = lowBits => highBits => {
    var buffer_ = []
    // Break the binary representation into chunks of 7 bits, set the 8th bit
    // in each chunk if it's not the final chunk, and append to the result.
    while (highBits > 0 || lowBits > 127) {
      buffer_.push((lowBits & 0x7f) | 0x80)
      lowBits = ((lowBits >>> 7) | (highBits << 25)) >>> 0
      highBits = highBits >>> 7
    }
    buffer_.push(lowBits)
    return buffer_
  }

  exports.splitInt64 = value => {
    var TWO_TO_32 = 4294967296
    // Convert to sign-magnitude representation.
    var sign = (value < 0)
    value = Math.abs(value)

    // Extract low 32 bits and high 32 bits as unsigned integers.
    var lowBits = value >>> 0
    var highBits = Math.floor((value - lowBits) /
                              TWO_TO_32)
    highBits = highBits >>> 0

    // Perform two's complement conversion if the sign bit was set.
    if (sign) {
      highBits = ~highBits >>> 0
      lowBits = ~lowBits >>> 0
      lowBits += 1
      if (lowBits > 0xFFFFFFFF) {
        lowBits = 0
        highBits++
        if (highBits > 0xFFFFFFFF) highBits = 0
      }
    }

    return { low: lowBits, high: highBits }
  }

  exports.splitBigInt = value => {
    var TWO_TO_32 = 4294967296n
    // Convert to sign-magnitude representation.
    var sign = (value < 0)
    value = sign ? -value : value

    // Extract low 32 bits and high 32 bits as unsigned integers.
    var lowBits = BigInt.asUintN(32, value)
    var highBits = Math.floor(Number((value - lowBits) / TWO_TO_32))
    highBits = highBits >>> 0

    lowBits = Number(lowBits)

    // Perform two's complement conversion if the sign bit was set.
    if (sign) {
      highBits = ~highBits >>> 0
      lowBits = ~lowBits >>> 0
      lowBits += 1
      if (lowBits > 0xFFFFFFFF) {
        lowBits = 0
        highBits++
        if (highBits > 0xFFFFFFFF) highBits = 0
      }
    }

    return { low: lowBits, high: highBits }
  }
})(PS["Proto.Encode"] = PS["Proto.Encode"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Proto.Encode"] = $PS["Proto.Encode"] || {};
  var exports = $PS["Proto.Encode"];
  var $foreign = $PS["Proto.Encode"];
  var Data_Array = $PS["Data.Array"];
  var Proto_Uint8Array = $PS["Proto.Uint8Array"];
  var Proto_Utf8 = $PS["Proto.Utf8"];                
  var unsignedVarint32 = (function () {
      var loop = function ($copy_acc) {
          return function ($copy_val) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, val) {
                  var $1 = val > 127;
                  if ($1) {
                      $tco_var_acc = Data_Array.snoc(acc)(val & 127 | 128);
                      $copy_val = val >>> 7;
                      return;
                  };
                  $tco_done = true;
                  return Data_Array.snoc(acc)(val);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_val);
              };
              return $tco_result;
          };
      };
      var $9 = loop([  ]);
      return function ($10) {
          return Proto_Uint8Array.fromArray($9($10));
      };
  })();
  var string = function (x) {
      var len = Proto_Utf8.numOfBytes(x);
      var $2 = len === 0;
      if ($2) {
          return unsignedVarint32(0);
      };
      return Proto_Uint8Array.concatAll([ unsignedVarint32(len), Proto_Utf8.toUint8Array(x)(len) ]);
  };
  var signedVarint64 = function (y) {
      var x = $foreign.splitInt64(y);
      return $foreign.writeSplitVarint64(x.low)(x.high);
  };
  var signedVarint32 = function (x) {
      if (x >= 0) {
          return unsignedVarint32(x);
      };
      var loop = function ($copy_acc) {
          return function ($copy_val) {
              return function ($copy_i) {
                  var $tco_var_acc = $copy_acc;
                  var $tco_var_val = $copy_val;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(acc, val, i) {
                      if (i < 9) {
                          $tco_var_acc = Data_Array.snoc(acc)(val & 127 | 128);
                          $tco_var_val = val >> 7;
                          $copy_i = i + 1 | 0;
                          return;
                      };
                      $tco_done = true;
                      return Data_Array.snoc(acc)(1);
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_acc, $tco_var_val, $copy_i);
                  };
                  return $tco_result;
              };
          };
      };
      return Proto_Uint8Array.fromArray(loop([  ])(x)(0));
  };
  var $$double = function (y) {
      var fixedUint32 = function (x) {
          return Proto_Uint8Array.fromArray([ x >>> 0 & 255, x >>> 8 & 255, x >>> 16 & 255, x >>> 24 & 255 ]);
      };
      var x = $foreign.splitFloat64(y);
      return Proto_Uint8Array.concatAll([ fixedUint32(x.low), fixedUint32(x.high) ]);
  };
  var bytes = function (xs) {
      var len = Proto_Uint8Array.length(xs);
      var $7 = len === 0;
      if ($7) {
          return unsignedVarint32(0);
      };
      return Proto_Uint8Array.concatAll([ unsignedVarint32(len), xs ]);
  };
  var $$boolean = function (v) {
      if (v) {
          return Proto_Uint8Array.fromArray([ 1 ]);
      };
      if (!v) {
          return Proto_Uint8Array.fromArray([ 0 ]);
      };
      throw new Error("Failed pattern match at Proto.Encode (line 63, column 1 - line 63, column 33): " + [ v.constructor.name ]);
  };
  var bigInt = function (y) {
      var x = $foreign.splitBigInt(y);
      return $foreign.writeSplitVarint64(x.low)(x.high);
  };
  exports["signedVarint32"] = signedVarint32;
  exports["unsignedVarint32"] = unsignedVarint32;
  exports["signedVarint64"] = signedVarint64;
  exports["bigInt"] = bigInt;
  exports["double"] = $$double;
  exports["string"] = string;
  exports["boolean"] = $$boolean;
  exports["bytes"] = bytes;
  exports["splitFloat64"] = $foreign.splitFloat64;
  exports["writeSplitVarint64"] = $foreign.writeSplitVarint64;
  exports["splitInt64"] = $foreign.splitInt64;
  exports["splitBigInt"] = $foreign.splitBigInt;
})(PS);